<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Metaballs - Marching Squares</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0a0a0f;
      color: #fff;
      font-family: system-ui, sans-serif;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    #controls {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 8px;
      font-size: 14px;
      z-index: 100;
    }
    label {
      display: block;
      margin: 8px 0;
      cursor: pointer;
    }
    input[type="checkbox"] {
      margin-right: 8px;
    }
    input[type="range"] {
      width: 150px;
      vertical-align: middle;
    }
    .value {
      display: inline-block;
      width: 40px;
      text-align: right;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div id="controls">
    <strong>Debug Visualization</strong>
    <label><input type="checkbox" id="showGrid"> Show grid</label>
    <label><input type="checkbox" id="showField"> Show field values</label>
    <label><input type="checkbox" id="showCorners"> Show corner states</label>
    <label><input type="checkbox" id="showCases"> Show case numbers</label>
    <label>
      Grid size: <input type="range" id="gridSize" min="10" max="80" value="40">
      <span class="value" id="gridSizeVal">40</span>
    </label>
    <label>
      Threshold: <input type="range" id="threshold" min="0.5" max="2" step="0.1" value="1">
      <span class="value" id="thresholdVal">1.0</span>
    </label>
  </div>

  <script>
/**
 * METABALLS WITH MARCHING SQUARES
 * ================================
 *
 * CONCEPT:
 * --------
 * Metaballs create blobby shapes that merge together smoothly.
 *
 * 1. SCALAR FIELD: Each metaball emits "energy" that decreases with distance.
 *    At any point (x,y), we sum the energy from all metaballs:
 *
 *    field(x,y) = Σ (radius² / distance²)
 *
 *    Close to a ball → high energy. Far away → low energy.
 *
 * 2. THRESHOLD: We define a "surface" where field = threshold (e.g., 1.0)
 *    - field > threshold → inside the blob
 *    - field < threshold → outside the blob
 *
 * 3. MARCHING SQUARES: Algorithm to find and draw that surface.
 *    - Divide canvas into a grid of cells
 *    - At each corner, sample: is it inside (1) or outside (0)?
 *    - 4 corners × 2 states = 16 possible configurations
 *    - Each configuration tells us how to draw the contour through that cell
 */

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// Debug controls
const controls = {
  showGrid: document.getElementById('showGrid'),
  showField: document.getElementById('showField'),
  showCorners: document.getElementById('showCorners'),
  showCases: document.getElementById('showCases'),
  gridSize: document.getElementById('gridSize'),
  threshold: document.getElementById('threshold'),
};

let CONFIG = {
  gridSize: 40,      // Size of each grid cell in pixels
  threshold: 1.0,    // Field value that defines the surface
  ballCount: 5,
};

let width, height, cols, rows;
let balls = [];

// ============================================
// STEP 1: DEFINE THE METABALLS
// ============================================

function createBall() {
  const angle = Math.random() * Math.PI * 2;
  const speed = 0.5 + Math.random() * 1.5;
  return {
    x: Math.random() * width,
    y: Math.random() * height,
    radius: 60 + Math.random() * 80,  // Affects field strength
    vx: Math.cos(angle) * speed,
    vy: Math.sin(angle) * speed,
  };
}

// ============================================
// STEP 2: THE SCALAR FIELD FUNCTION
// ============================================

/**
 * Calculate the field value at point (x, y)
 *
 * Each ball contributes: radius² / distance²
 * This creates a smooth falloff from each ball's center.
 *
 * When balls are close, their fields ADD together,
 * which is why metaballs "merge" smoothly.
 */
function sampleField(x, y) {
  let sum = 0;
  for (const ball of balls) {
    const dx = x - ball.x;
    const dy = y - ball.y;
    const distSq = dx * dx + dy * dy;

    // Avoid division by zero
    if (distSq < 1) {
      sum += ball.radius * ball.radius;
    } else {
      sum += (ball.radius * ball.radius) / distSq;
    }
  }
  return sum;
}

// ============================================
// STEP 3: MARCHING SQUARES ALGORITHM
// ============================================

/**
 * MARCHING SQUARES LOOKUP TABLE
 *
 * Each cell has 4 corners. We check if each corner is inside (1) or outside (0).
 * This gives us a 4-bit number (0-15) representing the configuration.
 *
 * Corner numbering:
 *   0 --- 1
 *   |     |
 *   3 --- 2
 *
 * The case number is: corner0 * 1 + corner1 * 2 + corner2 * 4 + corner3 * 8
 *
 * Each case tells us which edges the contour crosses.
 * Edges are numbered:
 *   +--0--+
 *   |     |
 *   3     1
 *   |     |
 *   +--2--+
 *
 * The lookup table stores pairs of edge indices to connect.
 * Some cases have multiple line segments.
 */
const EDGE_TABLE = [
  [],           // Case 0:  all outside, no lines
  [[3, 0]],     // Case 1:  bottom-left inside
  [[0, 1]],     // Case 2:  top-right inside
  [[3, 1]],     // Case 3:  bottom-left + top-right inside
  [[1, 2]],     // Case 4:  bottom-right inside
  [[3, 0], [1, 2]], // Case 5:  bottom-left + bottom-right inside (ambiguous)
  [[0, 2]],     // Case 6:  top-right + bottom-right inside
  [[3, 2]],     // Case 7:  only top-left outside
  [[2, 3]],     // Case 8:  top-left inside
  [[2, 0]],     // Case 9:  top-left + bottom-left inside
  [[0, 1], [2, 3]], // Case 10: top-left + top-right inside (ambiguous)
  [[2, 1]],     // Case 11: only bottom-right outside
  [[1, 3]],     // Case 12: top-left + bottom-right inside
  [[1, 0]],     // Case 13: only top-right outside
  [[0, 3]],     // Case 14: only bottom-left outside
  [],           // Case 15: all inside, no lines (we're fully inside)
];

/**
 * LINEAR INTERPOLATION
 *
 * Once we know an edge is crossed, we need to find WHERE on that edge.
 * If corner A has field value fA and corner B has field value fB,
 * and the threshold is T, we interpolate:
 *
 *   t = (T - fA) / (fB - fA)
 *
 * Then the crossing point is: A + t * (B - A)
 *
 * This gives us smooth contours instead of jagged pixel-aligned lines.
 */
function lerp(a, b, t) {
  return a + t * (b - a);
}

function getEdgePoint(x, y, edge, fieldValues, cellSize) {
  const threshold = CONFIG.threshold;
  const [f0, f1, f2, f3] = fieldValues;

  // Edge positions relative to cell top-left (x, y)
  switch (edge) {
    case 0: { // Top edge (between corners 0 and 1)
      const t = (threshold - f0) / (f1 - f0);
      return { x: lerp(x, x + cellSize, t), y: y };
    }
    case 1: { // Right edge (between corners 1 and 2)
      const t = (threshold - f1) / (f2 - f1);
      return { x: x + cellSize, y: lerp(y, y + cellSize, t) };
    }
    case 2: { // Bottom edge (between corners 2 and 3)
      const t = (threshold - f3) / (f2 - f3);
      return { x: lerp(x, x + cellSize, t), y: y + cellSize };
    }
    case 3: { // Left edge (between corners 0 and 3)
      const t = (threshold - f0) / (f3 - f0);
      return { x: x, y: lerp(y, y + cellSize, t) };
    }
  }
}

// ============================================
// RENDERING
// ============================================

function resize() {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
  cols = Math.ceil(width / CONFIG.gridSize) + 1;
  rows = Math.ceil(height / CONFIG.gridSize) + 1;
}

function init() {
  resize();
  balls = [];
  for (let i = 0; i < CONFIG.ballCount; i++) {
    balls.push(createBall());
  }
}

function update() {
  for (const ball of balls) {
    ball.x += ball.vx;
    ball.y += ball.vy;

    // Bounce off edges
    if (ball.x < 0 || ball.x > width) ball.vx *= -1;
    if (ball.y < 0 || ball.y > height) ball.vy *= -1;
  }
}

function draw() {
  ctx.clearRect(0, 0, width, height);

  const cellSize = CONFIG.gridSize;
  const threshold = CONFIG.threshold;

  // Pre-sample the entire grid
  // fieldGrid[row][col] = field value at that grid intersection
  const fieldGrid = [];
  for (let row = 0; row < rows; row++) {
    fieldGrid[row] = [];
    for (let col = 0; col < cols; col++) {
      fieldGrid[row][col] = sampleField(col * cellSize, row * cellSize);
    }
  }

  // Debug: show grid
  if (controls.showGrid.checked) {
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
    ctx.lineWidth = 1;
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        ctx.strokeRect(col * cellSize, row * cellSize, cellSize, cellSize);
      }
    }
  }

  // Process each cell
  for (let row = 0; row < rows - 1; row++) {
    for (let col = 0; col < cols - 1; col++) {
      const x = col * cellSize;
      const y = row * cellSize;

      // Get field values at 4 corners
      const f0 = fieldGrid[row][col];         // top-left
      const f1 = fieldGrid[row][col + 1];     // top-right
      const f2 = fieldGrid[row + 1][col + 1]; // bottom-right
      const f3 = fieldGrid[row + 1][col];     // bottom-left

      // Determine which corners are inside (field > threshold)
      const c0 = f0 > threshold ? 1 : 0;
      const c1 = f1 > threshold ? 1 : 0;
      const c2 = f2 > threshold ? 1 : 0;
      const c3 = f3 > threshold ? 1 : 0;

      // Calculate case number (0-15)
      const caseNum = c0 * 1 + c1 * 2 + c2 * 4 + c3 * 8;

      // Debug: show field values
      if (controls.showField.checked) {
        ctx.fillStyle = 'rgba(100, 200, 255, 0.6)';
        ctx.font = '10px monospace';
        ctx.fillText(f0.toFixed(1), x + 2, y + 10);
      }

      // Debug: show corner states (green = inside, red = outside)
      if (controls.showCorners.checked) {
        const radius = 4;
        [[c0, x, y], [c1, x + cellSize, y],
         [c2, x + cellSize, y + cellSize], [c3, x, y + cellSize]]
          .forEach(([inside, cx, cy]) => {
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fillStyle = inside ? '#0f0' : '#f00';
            ctx.fill();
          });
      }

      // Debug: show case numbers
      if (controls.showCases.checked && caseNum !== 0 && caseNum !== 15) {
        ctx.fillStyle = '#ff0';
        ctx.font = 'bold 14px monospace';
        ctx.fillText(caseNum, x + cellSize/2 - 7, y + cellSize/2 + 5);
      }

      // Draw the contour lines for this cell
      const edges = EDGE_TABLE[caseNum];
      const fieldValues = [f0, f1, f2, f3];

      ctx.strokeStyle = '#00ffff';
      ctx.lineWidth = 2;

      for (const [e1, e2] of edges) {
        const p1 = getEdgePoint(x, y, e1, fieldValues, cellSize);
        const p2 = getEdgePoint(x, y, e2, fieldValues, cellSize);

        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
      }
    }
  }

  // Draw ball centers for reference
  ctx.fillStyle = 'rgba(255, 100, 100, 0.5)';
  for (const ball of balls) {
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, 5, 0, Math.PI * 2);
    ctx.fill();
  }
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

// Event listeners
window.addEventListener('resize', () => { resize(); });

controls.gridSize.addEventListener('input', (e) => {
  CONFIG.gridSize = parseInt(e.target.value);
  document.getElementById('gridSizeVal').textContent = CONFIG.gridSize;
  resize();
});

controls.threshold.addEventListener('input', (e) => {
  CONFIG.threshold = parseFloat(e.target.value);
  document.getElementById('thresholdVal').textContent = CONFIG.threshold.toFixed(1);
});

// Initialize and run
init();
loop();

/**
 * TRY THIS:
 * ---------
 * 1. Enable "Show grid" to see the cells
 * 2. Enable "Show corners" to see which points are inside (green) vs outside (red)
 * 3. Enable "Show cases" to see which of the 16 cases each cell is
 * 4. Increase grid size to see the algorithm more clearly
 * 5. Decrease grid size for smoother output
 * 6. Adjust threshold to see how it changes the surface boundary
 */
  </script>
</body>
</html>
